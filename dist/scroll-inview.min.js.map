{"version":3,"file":"scroll-inview.min.js","sources":["../src/index.ts"],"sourcesContent":["/**\n * Scroll in viewport add data attribute\n * スクロールしてビューポートに入ったらdata属性を与える\n *\n * @author   Hiroshi Fukuda <info.sygnas@gmail.com>\n * @license  MIT\n */\n\n\nimport { TTargetItem, TTargetList } from \"./types\";\n\nconst ATTR_INVIEW: string = 'data-inview';\nconst ATTR_ROOT: string = 'data-inview-root';\nconst ATTR_MARGIN: string = 'data-inview-rootMargin';\nconst ATTR_THRESHOLD: string = 'data-inview-threshold';\n\nconst DEFAULT: IntersectionObserverInit = {\n  root: null,\n  rootMargin: '0px',\n  threshold: 0,\n};\n\n/**\n * in view controller\n */\nexport default class {\n\n  private targetList: TTargetList;\n  private opt: IntersectionObserverInit;\n\n  /**\n   * コンストラクタ\n   * ターゲット一覧を精査して、 data-inview-root、data-inview-rootMargin、data-inview-threshold が設定されていないか確認する。\n   * 上記属性毎に observer を作成する。\n   */\n  constructor(target: string, option: IntersectionObserverInit = {}) {\n    this.targetList = {};\n    this.opt = Object.assign(DEFAULT, option);\n\n    document.querySelectorAll<HTMLElement>(target).forEach((target: HTMLElement)=>{\n      this.initTargetList(target);\n    });\n  }\n\n  /**\n   * ターゲットとオプションの管理リストを作成\n   */\n  private initTargetList(target: HTMLElement): void {\n    // 監視対象エレメントに独自指定があればそちらを使う。\n    // 無ければオプション設定を使う\n    const root = target.getAttribute(ATTR_ROOT) || this.opt.root;\n    const rootMargin: string = target.getAttribute(ATTR_MARGIN) || this.opt.rootMargin as string;\n    const threshold: number = Number(target.getAttribute(ATTR_THRESHOLD)) || this.opt.threshold as number;\n    const key: string = `${root}-${rootMargin}-${threshold}`;\n\n    if (key in this.targetList === false){\n      const option: IntersectionObserverInit = {\n        root: root as HTMLElement,\n        rootMargin: rootMargin,\n        threshold: threshold,\n      };\n      const observer: IntersectionObserver = new IntersectionObserver(this.observerCallback, option);\n\n      this.targetList[key] = {\n        list: [],\n        observer\n      };\n    }\n    this.targetList[key].list.push(target);\n  }\n\n  /**\n   * スクロール検知処理を開始\n   */\n   public start(): void {\n    Object.keys(this.targetList).forEach(key => {\n      const targetObj = this.targetList[key];\n\n      targetObj.list.forEach(target => {\n        targetObj.observer.observe(target);\n      });\n    });\n  }\n\n  /**\n   * 画面に入ったら ATTR_INVIEW のdata属性に true を入れる。\n   * オブザーバーから監視解除される。\n   */\n   private observerCallback(entries: IntersectionObserverEntry[], observer: IntersectionObserver): void {\n    entries.forEach(entry => {\n      if(!entry.isIntersecting) return;\n\n      observer.unobserve(entry.target);\n      entry.target.setAttribute(ATTR_INVIEW, 'true');\n    });\n  }\n}\n\n\n"],"names":["DEFAULT","root","rootMargin","threshold","target","option","targetList","opt","Object","assign","document","querySelectorAll","forEach","_this","initTargetList","getAttribute","this","Number","key","observer","IntersectionObserver","observerCallback","list","push","keys","targetObj","_this2","observe","entries","entry","isIntersecting","unobserve","setAttribute"],"mappings":";;;;;;;KAWA,IAKMA,EAAoC,CACxCC,KAAM,KACNC,WAAY,MACZC,UAAW,2BAgBCC,cAAgBC,yDAAmC,mEACxDC,WAAa,QACbC,IAAMC,OAAOC,OAAOT,EAASK,GAElCK,SAASC,iBAA8BP,GAAQQ,SAAQ,SAACR,GACtDS,EAAKC,eAAeV,2DAOhB,SAAeA,OAGfH,EAAOG,EAAOW,aAtCE,qBAsCyBC,KAAKT,IAAIN,KAClDC,EAAqBE,EAAOW,aAtCV,2BAsCuCC,KAAKT,IAAIL,WAClEC,EAAoBc,OAAOb,EAAOW,aAtCb,2BAsC8CC,KAAKT,IAAIJ,UAC5Ee,YAAiBjB,cAAQC,cAAcC,MAEzCe,KAAOF,KAAKV,YAAe,EAAM,KAC7BD,EAAmC,CACvCJ,KAAMA,EACNC,WAAYA,EACZC,UAAWA,GAEPgB,EAAiC,IAAIC,qBAAqBJ,KAAKK,iBAAkBhB,QAElFC,WAAWY,GAAO,CACrBI,KAAM,GACNH,SAAAA,QAGCb,WAAWY,GAAKI,KAAKC,KAAKnB,wBAMzB,sBACNI,OAAOgB,KAAKR,KAAKV,YAAYM,SAAQ,SAAAM,OAC7BO,EAAYC,EAAKpB,WAAWY,GAElCO,EAAUH,KAAKV,SAAQ,SAAAR,GACrBqB,EAAUN,SAASQ,QAAQvB,yCASxB,SAAiBwB,EAAsCT,GAC9DS,EAAQhB,SAAQ,SAAAiB,GACVA,EAAMC,iBAEVX,EAASY,UAAUF,EAAMzB,QACzByB,EAAMzB,OAAO4B,aAlFS,cAkFiB"}